Layer 1 (DeviceManager) 코드 구조 및 개선 계획
1. 현재 구현된 코드 구조와 기능 상태 요약 📋
백엔드 (FastAPI): backend/app/ 아래 API 라우터와 서비스 계층으로 구성되어 있습니다. 주요 엔드포인트는 v1/devices (디바이스 스캔/프로필 관리)와 v1/calibration (좌표 캘리브레이션)이며, 각각 FastAPI APIRouter로 분리되어 있습니다[1][2]. 예를 들어, devices.py에서는 USB로 연결된 안드로이드 기기를 스캔하고(GET /devices/scan), 선택한 기기를 프로필로 연결하며(POST /devices/connect/{id}), 프로필 및 좌표의 CRUD 기능을 제공합니다[3][4]. calibration.py는 인터랙티브 좌표 설정을 담당하며, 새로운 캘리브레이션 세션 시작 (POST /calibration/sessions), 진행 중인 세션 정보 조회 및 제출 (GET/POST /calibration/sessions/{id}), 전체 가이드 출력 (GET /calibration/guide), 실시간 화면 스트리밍을 위한 WebSocket (/calibration/ws/{device_id}) 엔드포인트를 포함합니다[5][6].
주요 서비스 및 모듈:
DeviceManager 클래스는 디바이스 프로필 및 좌표 관리의 핵심 로직을 구현합니다. ADB 연결 기기 검색 (list_connected_devices 호출)과 신규 프로필 생성/조회, 프로필 리스트/삭제, 좌표 저장 및 업데이트/삭제 등을 처리합니다[7][8]. 새 기기 프로필 생성 시 해상도별 기본 좌표 세트를 초기화하여 주요 UI 요소 위치를 추정 저장하도록 되어 있습니다[9][10].
ADBController 클래스는 ADB를 통한 기기 제어를 추상화하여, 디바이스 연결 및 정보 조회, 터치 이벤트(tap, swipe), 키 입력(keyevent), 텍스트 입력, 클립보드 복사/붙여넣기 등 기능을 제공합니다[11][12]. 예를 들어 tap(x,y)은 ADB shell 명령 input tap을 실행하고 지연을 포함하며[12][13], launch_app 메서드는 주어진 패키지를 실행 (monkey 활용)하여 네이버 블로그 앱을 여는 기능도 구현되어 있습니다[14][15].
Calibration 워크플로우: calibration.py 내에 11~12단계의 UI 요소 목록 CALIBRATION_STEPS가 정의되어 있으며[16][17], 예를 들어 1단계는 “+ 버튼 (글쓰기 메뉴 호출)”, 2단계는 “블로그 글쓰기 버튼”, ... 마지막 단계는 “링크 복사 버튼”까지 사람이 블로그 포스팅 시 눌러야 하는 주요 UI 요소들의 순서를 나타냅니다. 각 단계마다 안내 문구와 도움말이 포함되어 있어 관리자 페이지에 표시되며, 사용자가 해당 디바이스 실시간 화면을 보고 지시에 따라 클릭하면 프론트엔드가 해당 좌표를 백엔드 (submit_coordinate)로 전송합니다[18][19]. 백엔드는 좌표를 DB에 저장하고 다음 단계 정보를 반환하여 프론트엔드에 진행 상태를 업데이트합니다[20][21]. 이 과정에서 WebSocket을 통해 주기적으로 스크린샷 이미지(약 2 FPS로 갱신)를 보내 실시간 화면 스트리밍을 구현하며[22][23], 사용자가 클릭한 좌표에는 녹색 마커로 피드백을 주는 등 UI 상호작용을 지원합니다.
프론트엔드 (Next.js 14+ & TypeScript): frontend/에는 관리자 대시보드 웹 UI가 구현되어 있습니다. Next.js App Router 구조로 /admin/devices (디바이스 목록/관리)와 /admin/calibration (좌표 캘리브레이션 마법사) 페이지가 있으며, 현재 경로 설정 이슈로 실제 URL은 /devices, /calibration로 동작하고 있습니다[24][25]. 프론트엔드 컴포넌트는 크게 디바이스 관리와 캘리브레이션 마법사로 나뉩니다. DeviceScanner 컴포넌트는 “디바이스 스캔” 버튼을 제공하고 API 호출로 USB 연결된 기기를 검색하여 리스트를 표시한 뒤, 각 기기별 “Connect” 버튼으로 백엔드 /devices/connect를 호출해 프로필을 생성/불러오는 흐름입니다[26][27]. 연결 성공 시 alert 후 페이지를 새로고침하여, 최신 프로필 목록을 반영하도록 구현되어 있습니다[28]. 또 device-list 컴포넌트(미완성 추정)는 DB에 저장된 모든 프로필을 보여주고 캘리브레이션 상태(예: 완료 여부 ✅) 등을 표시하도록 기획되어 있습니다.
CalibrationWizard 컴포넌트는 선택된 프로필에 대해 캘리브레이션 세션을 시작하고, WebSocket을 연결하여 디바이스 화면 캔버스를 렌더링합니다. 진행 단계와 지시문을 우측에 띄워주며, 사용자가 캔버스를 클릭하면 해당 좌표를 얻어 (<canvas> 클릭 위치를 이미지 좌표로 환산) 백엔드에 전송합니다[29][30]. 각 단계 전송 후 받은 다음 단계 정보를 토대로 진행률을 업데이트하고, 완료 시 “Calibration Complete” 표시와 함께 세션이 종료됩니다[31][32]. 에러 처리로는, 스캔 시 기기가 없거나 연결 실패 등의 경우 화면에 오류 메시지를 표시하고[33][34], WebSocket 연결 오류나 좌표 제출 실패 시에도 에러 상태를 표시하도록 구현되어 있습니다[35][36].
데이터 저장: SQLite DB (data/database.db)를 사용하여 SQLAlchemy ORM 기반으로 프로필(DeviceProfile)과 좌표 설정값(CoordinateConfig)을 영구 저장합니다[37][38]. Profile ID는 모델명+해상도 해시로 생성되며 동일 스펙 디바이스는 하나의 프로필을 공유하게 설계되었습니다[39][40]. DeviceProfile에는 여러 기기의 ID 목록, 해상도, DPI와 함께 해당 기기의 좌표 보정 완료 여부(calibrated=True/False)와 신뢰도 점수까지 저장해 두며, 관련 좌표들과 일대다 관계를 맺습니다[41][42]. 프로필 삭제 시 연결된 좌표들을 DB에서 자동 삭제하도록 cascade="all, delete-orphan" 옵션이 설정되어 데이터 정합성을 유지합니다[42]. 좌표(CoordinateConfig)에는 UI 요소 타입과 이름, (x,y)좌표, 신뢰도, 검증 여부, 보정 방법(사용자 클릭/AI/기본값) 등 상세 메타데이터까지 저장하여, 나중에 좌표별 성공/실패 횟수와 사용 빈도 등의 통계를 낼 수 있게 필드가 준비되어 있습니다[43][44].
현재 구현 상태 요약: 요약하면 Layer 1(DeviceManager) 단계의 핵심 기능들은 대부분 코드로 구현 완료된 상태입니다. FastAPI 백엔드로 ADB 기기 연결 제어 (adbutils 활용)와 디바이스 프로필/좌표 DB 관리 기능이 마련되었고, Next.js 프론트엔드로 관리자 UI에서 기기 검색/연결, 화면 미러링을 통한 좌표 캘리브레이션 워크플로우가 작동합니다. 실제 네이버 앱을 자동으로 조작하기 위한 필요 좌표 데이터 수집 파이프라인은 구축되었다고 볼 수 있습니다. 이제 수집된 좌표를 활용해 블로그 포스팅 전체 과정을 자동화로 실행하는 로직(일종의 매크로 경로)이 남은 과제입니다. 또한 현재 구현에서 추후 개선 여지가 있는 부분(예: UIAutomator 활용, scrcpy 사용 등)은 설계 문서에도 언급되어 있으며[45][46], 다음 섹션들에서 상세히 다루겠습니다.
2. 클로드코드의 작업 방식 분석 – 발견한 문제점과 좋은 패턴 ✅❗
구조적 모듈화 (장점): 우선 클로드코드(협업 AI)가 생성한 프로젝트는 레이어드 아키텍처를 비교적 명확히 구분했습니다. API 엔드포인트와 핵심 로직, DB 모델, 스키마 정의를 각각 다른 모듈로 분리하여 유지보수성을 높인 점이 좋습니다. 예를 들어 ADB 제어 로직은 ADBController에 모아두고, DB 연동과 비즈니스 로직은 DeviceManager에서 처리하며, FastAPI 라우터는 이들을 호출만 하도록 역할을 구분했습니다. 이런 설계는 관심사의 분리 원칙을 잘 지킨 것으로 평가됩니다. 또한 데이터 모델링 측면에서도, Pydantic 스키마(schemas/)를 활용해 입출력 payload를 명확히 정의하고, SQLAlchemy ORM을 통해 관계형 데이터 관리까지 일관성 있게 구현한 점이 돋보입니다. 예컨대 디바이스-좌표 간 일대다 관계 및 삭제 연동(cascade)도 빠뜨리지 않은 점[42], 프로필 ID 생성에 해시 기법을 사용해 중복을 방지한 점[40], 여러 물리 기기를 하나의 프로필로 관리하려고 device_ids를 JSON 배열로 갖는 등 대량 운영을 염두에 둔 설계도 눈에 띕니다. 또한 UI 좌표에 대해 Enum 타입으로 정의(UIElementType)해둔 부분도 확장성과 가독성 측면에서 좋은 패턴입니다[47]. 이를 통해 코드에서 각 UI 요소를 문자열이 아닌 상수로 취급하여 오타를 줄이고, 나중에 새로운 요소를 추가하기도 용이합니다.
기능 구현의 충실도 (장점): 클로드코드는 대화 내용과 사전에 주어진 설계 명세를 비교적 충실히 코드에 반영했습니다. 예를 들어, 초기 ADB 연결 방식으로 adbutils 라이브러리를 도입하여 안정성을 높였고, 실제 adb.device_list() 등을 활용해 멀티디바이스 지원 기반을 마련했습니다[48]. 또 좌표 기반 자동화의 한계를 보완하기 위해 AI Vision 및 UIAutomator2 통합을 고려했는데, 비록 해당 부분이 완전히 구현되진 않았으나, 코드 곳곳에 그런 확장 가능성을 염두에 둔 구조가 보입니다 (예: CalibrationMethod enum에 AI_VISION 옵션 포함[49], DeviceManager._initialize_default_coordinates에서 해상도 비례로 좌표 계산하여 디폴트 값 제공 등). 로그 남기기 부분도 꼼꼼히 처리되어 있습니다. Loguru를 이용한 통합 로깅 설정과[50][51] 각 핵심 동작에 logger.info/debug/error를 호출한 부분들이 많아, 추후 문제 발생 시 추적이 용이합니다. 추가로, debug_logger.py를 별도로 두어 캘리브레이션 세션 중 발생하는 모든 이벤트(클릭 좌표, 스크린샷, 에러)를 JSON Lines 파일과 이미지로 자동 기록하는 기능까지 구현한 점도 훌륭한 디버깅 패턴입니다[52][53]. 이러한 노력은 서비스 운영 단계에서 장애 상황을 재현하고 원인을 분석하는데 큰 도움이 될 것입니다.
신속한 작업 진행 (패턴): 클로드코드와의 협업 내역을 보면, 비교적 큰 단위의 기능을 한꺼번에 작성 및 커밋하는 경향이 있었습니다[54]. 예를 들어 DeviceManager Layer 구현 커밋 하나에 120개 파일, 3만4천여 줄을 한번에 추가했는데, 이는 AI가 대화를 통해 획득한 요구사항을 기반으로 일괄적으로 구조를 세팅했음을 의미합니다. 이러한 접근은 초기 프로토타이핑 단계에서는 속도를 높이는 장점이 있지만, 동시에 몇 가지 사소한 버그나 누락을 발생시켰습니다. 실제로도 프론트엔드 라우팅이나 import 오류 등의 자잘한 수정 커밋이 후속으로 필요했습니다[55]. 요약하면, 클로드코드는 큰 그림을 빠르게 코드화하는 능력은 탁월하나, 세부적인 부분에서 사람의 검증과 보완이 아직 필요했습니다.
발견된 문제점 (이슈):
Next.js 라우팅 혼선 – 프론트엔드에서 app/(admin)/... 폴더 구조를 사용한 탓에, 실제 경로 URL에 admin 세그먼트가 포함되지 않는 문제가 있었습니다[56]. 이로 인해 초기 /admin/devices 등을 직접 열면 404가 발생하고, 실제 페이지는 /devices로 접근해야 하는 혼선이 생겼습니다. 이는 클로드코드가 Next.js 13+의 Route Group 문법을 오인한 것으로 보입니다. 이후 이 문제는 내비게이션 링크를 /devices, /calibration으로 수정하는 방식으로 해결되었지만, 애초에 의도와 다르게 동작하도록 폴더 구조를 짠 것은 작은 실수였습니다.
UI Element 타입 정의의 일관성 – UIElementType 열거형에서 일부 이름이 실제 용도와 맞지 않게 사용된 부분이 있습니다. 예를 들면 BOLD_BUTTON은 원래 “굵게” 토글 버튼을 가리키는 이름이나, 캘리브레이션 단계에서는 ‘가장 작은 글자 크기 선택’ 단계에 이 타입을 재사용했습니다[19]. 또한 HOME_BUTTON 타입은 실제로는 ‘블로그 글쓰기 메뉴 버튼’을 의미하도록 쓰였습니다[57]. 이러한 네이밍 부정확은 코드 이해를 어렵게 하고 잠재적 오해를 부르므로, 추후 타입을 세분화하거나 이름을 바꾸는 리팩토링이 필요해 보입니다 (예: SMALLEST_TEXT_OPTION 등을 추가 정의).
경로 설정 및 동작 누락 – Layer 1의 목표 중 하나는 “사람처럼 경로를 판단하며 버튼을 누르는 자동화”인데, 현재 좌표를 이용한 단일 동작들은 구현됐지만 이것들을 연결하여 전체 포스팅 시나리오를 자동화로 수행하는 함수는 구현이 안 된 상태입니다. 예컨대, 수집된 좌표를 차례대로 호출해서 “+ -> 블로그쓰기 -> 제목입력 -> 본문입력 -> ... -> 발행 -> 공유 -> 링크복사”까지 쭉 눌러주는 루틴이 없습니다. 이 부분은 사실 Layer 1과 Layer 3 (Automation Executor)의 경계에 걸친 기능이지만, 클로드코드가 이를 놓쳤기 때문에 현재는 사용자가 일일이 앱을 눌러보는 반자동 상태라 할 수 있습니다. 향후 이 UI 탐색 자동화 루틴을 추가해야 비로소 사람이 하는 행동을 완전 대체하게 됩니다 (섹션 5에서 구체적 제안).
일부 기능 미구현/자리표시만 – 코드 구조 상 존재하나 실제 로직이 비어있거나 미완성인 부분도 있습니다. 예를 들어, backend/app/api/v1/screen.py 파일은 프로젝트 구조에 명시만 되고 아직 작성되지 않았습니다 (현재 실시간 화면은 calibration의 WebSocket으로 해결). 또 IP 변경 로직이나 AI Vision 분석 통합은 설계 문서에는 포함되었으나 코드에는 구현이 보이지 않습니다[58]. 클로드코드가 후속 작업을 염두에 두고 VisionAnalyzer 클래스 인터페이스나 IP 변경 관련 ADB 명령 (예: 비행기모드 토글) 등을 남겨두지 않았기에, 이 부분은 추후 개발자가 직접 구현해야 합니다.
성능 및 효율 이슈 – 현재 화면 스트리밍은 0.5초마다 전체 스크린샷을 Base64로 인코딩해 보내는 방식[22]으로, 다소 비효율적입니다. 클로드코드는 우선 쉬운 구현을 택했지만, 추후 scrcpy와 같은 고성능 미러링 도구를 연동하지 않으면 디바이스 해상도가 높을수록 대시보드 지연이 커질 수 있습니다. 또한 좌표 기반 터치 후 UI 반응을 확인하는 절차가 없어, 만약 어떤 단계에서 터치가 먹히지 않으면 다음 단계로 넘어가버릴 위험도 있습니다 (예: 팝업이 안 떴는데 다음 좌표를 바로 터치하는 경우 등). 이러한 검증 부족은 추후 AI Vision이나 UIAutomator 통합으로 해결할 계획이나, 현재 구현에는 빠져있는 상태입니다[59][60].
코드 스타일 및 사용자 경험 – 전반적으로 코드 스타일은 양호하나, 프론트엔드에서 alert() + window.location.reload()로 새로고침하는 부분[28]은 사용자 경험상 거친 편입니다. 연결 후 곧바로 프로필 리스트를 리프레시하려는 의도인데, Next.js의 상태 관리(Zustand 등)나 라우터를 활용하면 부드럽게 갱신할 수 있었을 것입니다. 이 부분은 개발 편의를 위해 간단히 처리한 것으로 보이지만, 실제 프로덕션에서는 개선이 필요합니다.
요약하면, 클로드코드의 기여는 핵심 뼈대를 빠르게 구축하고 많은 기능 요구사항을 한꺼번에 구현해준 점이 크지만, 그 과정에서 일부 작은 논리 오류나 미흡한 부분이 생겨 향후 인간 개발자의 세심한 손질이 요구됩니다. 다행히 구조가 모듈화되어 있어, 특정 문제 영역만 찾아서 고치면 전체 시스템 완성도를 끌어올릴 수 있는 상태입니다.
3. 우선적으로 손볼 모듈 및 폴더 (개선 필요 영역) 🔧
지금 단계에서 가장 시급히 손봐야 할 부분과 해당 모듈/폴더는 다음과 같습니다:
① Next.js 라우팅 구성 수정 (frontend/src/app/(admin)/*): 현행 관리자 페이지 라우트는 (admin) 경로 그룹 폴더로 되어 있어 URL에 admin이 나타나지 않는 문제가 있습니다[56]. 이를 바로잡기 위해 폴더명을 admin으로 변경하거나, 현재처럼 경로 그룹을 유지하려면 내부 링크를 모두 /devices -> /admin/devices로 교체하고 Next.js에 group 동작을 명시적으로 처리해야 합니다. 권장 방안은 단순하게 폴더명을 app/admin/으로 변경하는 것입니다. 이 경우 브라우저 접속 경로가 /admin/devices, /admin/calibration으로 일관되게 동작하며, README 등 문서의 안내와 실제 경로가 일치하게 됩니다. 이 수정 후에는 AdminLayout에서의 <Link href="/devices"> 등을 /admin/devices로 바꾸고[24], 혹시 라우트 충돌이 있다면 app/page.tsx에서 /admin 경로로 리다이렉트하는 처리도 검토합니다.
② “사람처럼 누르는” UI 탐색 루틴 구현 (backend/app/services/ 새로운 함수): 가장 중요한 우선순위입니다. 현재 좌표가 모두 수집되는 만큼, 이를 사용하여 블로그 포스팅 과정을 자동화하는 함수를 작성해야 합니다. 예를 들어 DeviceManager 내지 별도 모듈에 def automate_posting(profile_id, title, content, image_path) 같은 메서드를 만들어, 해당 프로필의 좌표들을 순서대로 불러와 ADBController로 터치 이벤트를 발생시키도록 합니다. 이 때 단순히 좌표 나열만 할 것이 아니라 각 단계 사이에 검증과 예외 처리를 포함해야 합니다. (자세한 알고리즘 제안은 아래 5번 항목에서 다룹니다.) 이 모듈 구현을 통해 비로소 Layer1의 주 목표인 “디바이스를 사람처럼 자동 조작”이 실현됩니다. 해당 코드는 adb_controller.py의 메서드들(tap, input_text 등)을 활용하게 되며, UI 흐름에 따라 적절한 지연 (time.sleep)과 상태 확인을 포함해야 합니다. 이 작업은 Layer1과 Layer3의 경계를 잇는 핵심이므로 우선 개발착수 권장합니다.
③ 좌표 캘리브레이션 관련 모듈 정리 (backend/app/api/v1/calibration.py & DeviceManager 부분): 캘리브레이션 단계와 기본 좌표 초기값을 다루는 로직을 정돈해야 합니다. 현재는 CALIBRATION_STEPS 리스트[16][17]와 _initialize_default_coordinates 함수[9][10]에 중복된 UI 요소 목록이 관리되고 있습니다. 그런데 두 목록이 완전히 일치하지 않아 (예: 기본좌표엔 COPY_LINK_BUTTON 없음) 잠재적 불일치가 우려됩니다. 따라서 한 곳에서만 진실을 관리하도록 개선합시다. 방법으로는 CALIBRATION_STEPS 사전을 한군데 (calibration_service.py 등)로 옮기고, 기본 좌표도 이 리스트를 순회하며 생성하도록 변경하면 중복을 없앨 수 있습니다. 또한 앞서 지적된 잘못된 타입 사용 (BOLD_BUTTON 등)을 바로잡기 위해 enum과 해당 리스트 내용도 수정해야 합니다. 예를 들어 UIElementType에 SMALL_TEXT_OPTION을 추가하고 CALIBRATION_STEPS의 7번째 단계는 그것을 쓰도록, 그리고 _initialize_default_coordinates도 해당 항목을 추가하는 식입니다. 이 모듈 정리는 기능 변화는 아니지만 데이터 일관성과 코드를 이해하기 쉽게 만들기 위한 선행 작업으로 우선순위가 높습니다.
④ 프론트엔드 디바이스 관리 UI 마무리 (frontend/src/app/(admin)/devices/page.tsx 등): 현재 디바이스 관리 페이지는 DeviceScanner 컴포넌트를 통해 스캔 & 연결은 가능하지만, 이미 연결된 프로필들을 보여주는 프로필 리스트 UI는 누락된 것으로 보입니다. 사용자가 여러 기기를 순차 연결한 후 어떤 프로필이 생성되었는지, 캘리브레이션 완료 상태는 어떤지 한눈에 볼 수 있어야 합니다. 따라서 device-list.tsx 컴포넌트를 구현하거나, Scanner 컴포넌트 아래에 프로필 목록 섹션을 추가해야 합니다. 이 목록은 api.devices.listProfiles()를 호출하여 DB의 모든 프로필을 가져와 렌더링하고, 각 프로필에 “Calibrated ✅” 표시나 메모 등을 보여주면 좋습니다[61][62]. 또한 각 프로필 행에 삭제(삭제 시 /devices/profiles/{id} DELETE 호출)나 편집(메모 수정 등) 기능도 제공하면 관리가 수월해집니다. 프론트엔드 모듈의 이런 마무리 작업을 통해 관리자 대시보드에서 DeviceManager 레이어의 모든 기능을 UI로 제어할 수 있게 됩니다.
⑤ 성능 관련 모듈 점검:
스크린 미러링 – 현재 WebSocket으로 보내는 스크린샷은 해상도 높을 경우 병목이 될 수 있으므로, scrcpy 서버를 이용한 MJPEG 스트림이나 WebRTC 등을 검토해야 합니다. 이 작업은 Phase2로 계획된 부분이지만[63], 만약 현재 방식으로 속도가 매우 느리다면 우선 화면 업데이트 주기(예: 0.5초->1초)라도 조절하여 안정성을 확보합니다. 추후 scrcpy 도입시 screen.py 모듈을 통해 접속 포트를 프록시하거나, <code>adb reverse</code>로 scrcpy WebSocket을 프론트엔드에 전달하는 방식을 염두에 두고 구조를 짜두면 좋습니다.
ADB 명령 타임아웃/예외 처리 – adb_controller.py의 메서드들이 기본적으로 내부에서 예외 발생 시 logger.error로 기록하고 raise하지만, 상위 계층에서의 재시도 로직이 없습니다[64][65]. 예컨대 connect_device API에서 ADBController.connect() 실패 시 바로 400 에러 응답을 주는데[66], 이때 사용자가 USB를 뺐다 다시 꽂는 등의 재시도 여지를 줄 수 있도록 백엔드에서 몇 초 후 재시도하거나, 프론트엔드에서 “재시도” 버튼을 제공하는 개선이 필요합니다. 이는 성능이라기보다 안정성 이슈지만, DeviceManager 레이어의 완성도를 높이기 위해 함께 챙겨야 합니다.
⑥ 기타:
Config 및 상수 관리 – app/core/config.py에서 현재 ADB 타임아웃, 스크린샷 퀄리티 등의 상수를 지정하고 있는데, 혹시 하드코딩된 값들이 코드 내에 산재해 있다면 config로 이동시켜 정리해야 합니다. 예를 들어 TAP_DELAY_MS나 SWIPE_DURATION_MS 등이 설정 파일로 노출되어 조정 가능하도록 해두면, 디바이스마다 미세한 터치 지연을 조절하기 용이합니다.
로그 확인 UI – debug logger가 이벤트를 파일로 남기고 있지만, 이를 웹 UI에서 확인하려면 별도 다운로드나 노출 기능이 필요합니다. 관리자 페이지에 “디버그 세션 로그 다운로드” 링크를 제공하는 등도 고려하면 좋겠습니다 (우선순위는 낮음).
以上의 개선 항목들은 난이도와 필요도 면에서 조금씩 다르지만, 1)~4)는 당장 품질과 기능 완성도에 직결되는 사항이므로 최우선으로 처리해야 합니다. 특히 2)의 자동화 루틴 구현은 프로젝트의 주 목표 달성을 위한 필수 과제이며, 1)과 3), 4)는 현행 기능의 버그/불편 제거 차원에서 중요합니다.
4. 리팩토링 또는 구조 개선이 필요한 지점 🔨
다음은 코드 전반을 점검하여 식별한 리팩토링/구조 개선 포인트입니다 (일부는 앞의 항목과 겹치지만, 더 포괄적인 코드 품질 향상 관점에서 서술):
코드 중복 제거 및 일관성 확보: 앞서 언급한 CALIBRATION_STEPS 중복 정의 문제는 리팩토링이 반드시 필요합니다. 단일 소스로 UI 요소 정의를 관리하면, 예를 들어 새로운 UI 동작을 추가할 때 실수로 한 군데 빠뜨리는 일이 줄어듭니다. 또 API와 Frontend 양측에서 사용되는 상수값 (예: API URL prefix /api/v1, WebSocket 경로 등)을 통일되게 관리하도록 구조를 개선하면 좋습니다. 현재는 백엔드 settings.API_V1_PREFIX로 /api/v1을 정의하고 프론트에서는 .env.local에 NEXT_PUBLIC_API_URL로 기본 URL을 맞추고 있는데[67][68], 혹시 경로 prefix 변경 시 프론트엔드 코드도 같이 수정해야 하는 부분이 있다면 (.env만 바꾸면 끝나는지 점검) 이를 줄이는 방향으로 개선합니다.
Enum 및 타입 이름 개선: 2번 항목에서 지적한 잘못된 Enum 이름 외에도, 전반적으로 Enum 멤버들의 이름 규칙統一도 고려하세요. 예를 들어 UIElementType에 HOME_BUTTON과 MENU_BUTTON이 있는데, 실제 의미를 알기 어렵습니다 (네이버 블로그 앱에는 ‘홈’ 버튼과 ‘메뉴’ 버튼이 모두 존재 가능). 차라리 WRITE_MENU_BUTTON처럼 구체적으로 짓거나, 쓰이지 않는 Enum(MENU_BUTTON은 현재 캘리브레이션 목록에 없음)이라면 제거하는 게 낫습니다. 또한 프론트엔드의 타입(types.ts) 정의와 백엔드 스키마 정의가 중복되는 부분도 있는데, OpenAPI 스키마를 이용해 자동 생성하거나, 최소한 필드 이름은 동일하게 유지해야 합니다. (현재 profile 모델의 width,height를 프론트에선 resolution.width/height로 제공하는 등[69][70] 조금 차이가 있는데, 이런 부분은 프론트에서 변환하여 쓰도록 하거나 통일하도록 협의해야 합니다.)
예외 처리 및 Fallback 구조: 자동화 루틴을 구현할 때 고려해야 할 부분이지만, 구조 개선 측면에서 오류 발생시 롤백/대안 동작이 원활하도록 체계를 갖춰야 합니다. 예를 들어, DeviceManager.automate_posting (가칭)를 구현할 때 각 단계에서 실패 여부를 리턴값이나 예외로 받아서, 즉각 중단할지 재시도할지 판단하는 로직이 필요합니다. 이를 구현하려면 현재의 ADBController 메서드들이 단순히 실패 시 예외를 내보내는 것에서 한 단계 더 나아가, 성공/실패 boolean을 반환하고 내부에서 재시도나 대체수단(UIAutomator2 활용 시도 등)을 할 수 있도록 발전시킬 여지가 있습니다. 이러한 fallback 설계를 염두에 두고, 모듈들 간 인터페이스를 정리해두면 추후 Layer2/Layer3에서 AI Vision 등을 통합하기 수월해집니다[59][60]. (예: tap() 함수가 좌표를 눌렀는데 UI 변화가 없으면 False 반환 -> 상위에서 Vision으로 해당 UI 재검색 -> 좌표 업데이트 후 재시도 등의 흐름).
UI 상태 검증 로직 분리: 현재는 한 단계 눌렀을 때 다음 단계로 넘어가는 판단을 클라이언트가 해주지만, 실제 자동화시에는 백엔드가 UI 상태를 확인해야 합니다. 이를 위해 ADBController.get_current_activity()나 adb shell dumpsys 등을 활용하는 코드를 도입할 수 있습니다. 이러한 코드는 DeviceManager에 넣기보단 별도 StateVerifier 유틸 모듈로 분리하면 테스트나 교체(예: UIAutomator2로 전환)가 쉬워집니다. 리팩토링 관점에서 이 부분을 미리 설계해 두면, 나중에 Manus-style AI loop(Observe-Plan-Act)으로 바꾸기도 수월합니다[71].
Front/Back 간 동기화: 현재 프론트엔드와 백엔드 간에 API 명세는 잘 맞는 편이지만, 일부 개선점이 있습니다. 예를 들어 좌표를 프론트에서 제출할 때 CalibrationResult에 element_type을 담아 보내는데, 이 값이 나중에 안 쓰이고 있습니다 (session_id와 x,y만으로도 어떤 요소인지 알 수 있지만, 굳이 받는다면 활용하도록). 또한 프로필 연결 후 alert 대신, 연결된 프로필 정보를 프론트 상태로 보존해서 곧바로 캘리브레이션 페이지로 넘어가게 하는 UX 개선도 고려하세요. 이러한 부분은 구조라기보다는 동작 흐름 개선이지만, 큰 틀에서 보면 Layer1 단계의 인tegation 품질을 높이는 리팩토링입니다.
주석 및 문서 보완: 자동 생성된 주석과 Docstring이 많지만, 실제 개발자에게 가장 중요한 건 왜 이렇게 구현했는지에 대한 맥락입니다. 코드 상에 # TODO 주석으로 남겨야 할 부분 (예: “// TODO: UIAutomator2 integration fallback here”)을 클로드코드가 거의 남기지 않았으므로, 현재 파악한 개선 과제들을 코드 주석과 프로젝트 이슈 트래커에 남겨 두는 작업도 필요합니다. 이는 협업 및 향후 유지보수에 도움이 될 것입니다.
정리하면, 리팩토링의 키워드는 “중복 제거, 명명 개선, 오류대응 구조화, 검증 로직 강화”로 요약됩니다. 지금은 기능이 돌아가는 데 집중했다면, 다음 단계는 코드를 사람 개발자 기준에서 읽기 쉽고 변화에 유연하도록 다듬는 것입니다. 이 작업을 통해 Layer1의 코드베이스를 한층 견고한 기반으로 만들 수 있을 것입니다.
5. Layer 1 목표 달성을 위한 경로 설계 제안 (자동화 알고리즘) 🚦
Layer 1의 궁극적인 목표는 “네이버 앱을 사람처럼 자동으로 조작”하는 것입니다. 이를 위해 수립해야 할 경로(path) 및 알고리즘을 제안하면 다음과 같습니다:
사전 준비 단계: 대상 디바이스(Profile)를 선택하면, 앱 초기 상태를 보장해야 합니다. 즉 블로그 앱이 실행 중이며 홈 피드 화면이 떠 있는지를 확인하거나, 아니라면 앱을 실행시킵니다. 구현상 ADBController.launch_app("com.nhn.android.blog", ...)를 호출하여 네이버 블로그 앱을 띄우고, time.sleep(2) 정도 대기한 후 get_current_activity()로 현재 액티비티명을 확인합니다. 만약 앱이 아닌 다른 화면이거나 (로그인 화면 등) 예외 상황이면, 해당 경우를 처리(현재는 자동 로그인 미구현이므로 오류 리포트 후 중단)하도록 합니다.
1단계: 플러스(+) 버튼 눌러 메뉴 열기 – DeviceManager 또는 새로 만든 Automation 모듈에서, Profile의 좌표 DB에서 WRITE_BUTTON 좌표를 조회하여 adb.tap(x,y)을 실행합니다. 실행 후 메뉴 팝업이 떴는지 확인해야 합니다. UI 검증을 간단히 하기 위해 0.5~1초 지연 후 get_current_activity()나 화면 캡처를 뜬 뒤, 다음 단계 요소(“블로그 글쓰기”)의 존재 여부를 탐색하는 방법이 있습니다. AI Vision이 있다면 스크린샷 기반으로 “블로그 글쓰기” 글씨를 찾겠지만, 우선은 일정 시간 대기와 단순 신뢰 전략으로 진행합니다. 이때 터치 실패 가능성을 대비해 한두 번 재시도 로직을 추가해도 좋습니다.
2단계: “블로그 글쓰기” 버튼 누르기 – 좌표 DB에서 HOME_BUTTON (혹은 적절히 이름 변경된 글쓰기 메뉴 버튼) 좌표를 가져와 탭합니다[72]. 탭 후에는 에디터 화면으로 전환되어야 합니다. 이 전환은 mCurrentFocus 등으로 확인할 수 있는데 (...EditActivity 등의 문자열 포함 여부), 간단히 1~2초 대기 후 진행해도 됩니다. 만약 에디터 화면이 뜨지 않으면 (예: 플러스 메뉴가 안 열려서 클릭 못한 경우) 예외 처리를 합니다 – 이 시점에서 실패하면 이후 단계 진행 불가이므로, fallback으로 한 번 더 플러스->글쓰기 시도하거나 자동화를 중단하고 오류를 리턴합니다.
3단계: 제목 필드 선택 – 좌표 DB의 TITLE_FIELD 위치를 탭합니다. 이로써 키보드가 올라오고 제목 입력 가능해집니다. 텍스트 입력: 제목은 보통 “제목을 입력하세요” 필드에 입력해야 하므로, ADBController의 input_text() 또는 set_clipboard()+paste()를 이용해 준비된 제목 문자열을 넣습니다. 영어/숫자는 input_text로 직접 입력 가능하지만, 한글 등 특수문자는 잘 안될 수 있어 클립보드 이용을 권장합니다[73]. 예: controller.set_clipboard(title), 잠시 대기, controller.paste() (키 이벤트 279) 호출로 텍스트를 입력합니다. 제목 입력 완료 후 엔터 혹은 빈 곳 터치 등으로 포커스를 내려도 되지만, 굳이 필요 없으면 다음 단계로 넘어갑니다.
4단계: 본문 필드 선택 및 내용 입력 – 좌표 DB의 CONTENT_FIELD 위치를 탭하여 본문 입력 영역을 활성화합니다. 이후 제목과 같은 방식으로 본문 콘텐츠 텍스트를 입력합니다. (대용량 글일 경우 한 번에 입력이 어려울 수 있으니, 클립보드+paste를 여러 번에 나누어 할 수도 있습니다. 초기에는 단순하게 구현하고 추후 개선.) 텍스트 입력 후에도 엔터 등을 보내 커서를 끝에 위치시키는 등 필요에 따라 조정합니다.
5단계: 이미지 첨부 버튼 누르기 – 좌표 DB의 IMAGE_BUTTON (에디터 하단의 사진 아이콘)를 탭합니다. 이러면 보통 갤러리 권한 요청이나 갤러리 목록이 뜰 것입니다. 권한 요청이 뜨면 한번만 허용 터치를 해야 하고, 갤러리가 뜨면 첫 번째 이미지를 선택해야 합니다. 현재 캘리브레이션 단계에는 갤러리 관련 좌표가 없음에 유의하십시오. 따라서 갤러리 선택 과정은 두 가지 전략이 있습니다: (a) 고정 좌표로 처리 – 가장 최근 사진 썸네일 좌표를 미리 얻어 두었다면 그걸 탭, “선택” 버튼 좌표 탭 (UIElementType에 GALLERY_FIRST_IMAGE, GALLERY_SELECT_BUTTON 등이 정의되어 있으므로 활용 가능)[74]; (b) UIAutomator로 처리 – 이 부분만이라도 Resource ID로 찾아 누르는 방법. 초기에는 간단히 (a)로 구현하되, 좌표가 없다면 갤러리 기능 생략도 고려합니다. (이미지 첨부를 필수 기능으로 볼지 여부에 따라 결정.)
6단계: 텍스트 크기 조절 버튼 누르기 – 좌표 DB의 TEXT_SIZE_BUTTON (에이콘 ‘가’)를 탭합니다[75]. 하단 툴바에서 텍스트 크기 아이콘을 눌러 글자 크기 선택 팝업을 띄웁니다. 이어서 가장 작은 크기 선택 (현재는 BOLD_BUTTON로 명명된 좌표)[19]을 탭하여 본문 글씨 크기를 최소화합니다. 이 단계는 사용 목적상 글씨 크기를 통일하려는 것이므로, 좌표 정확도가 낮으면 실패할 가능성도 있습니다. 실패 시 크게 치명적이진 않으나 가급적 성공시키기 위해, 팝업이 뜬 후 약간 넉넉한 클릭(예: 해당 좌표 주변 몇 픽셀 내 랜덤)으로 시도하거나, 실패하면 한 번 더 탭하도록 합니다. 팝업이 닫혔는지 확인하고 (일정 시간 대기) 다음 단계로.
7단계: (선택 사항) 링크 추가 – 만약 이미지에 하이퍼링크를 거는 기능을 사용할 경우, 좌표 DB의 LINK_BUTTON을 탭하여 링크 입력 다이얼로그를 띄웁니다[76]. 그리고 여기에 URL을 입력하고 확인(확인 버튼 좌표 탭)하는 흐름이 추가될 수 있습니다. 이 부분은 옵션이므로, 필요 시 구현합니다. (자동화 관점에서는 링크 넣지 않아도 무방하다면 생략 가능)
8단계: 발행 버튼 누르기 – 본문 작성이 완료됐으면 우측 상단의 발행 버튼 좌표(PUBLISH_BUTTON)를 탭합니다[77]. 정상적으로 누르면 발행 완료 화면 혹은 발행 옵션 창이 뜰 수 있습니다. 네이버 블로그의 경우 곧바로 발행되기도 하지만, 가끔 “공개 설정” 등의 창이 나올 수 있는데, 이 경우 CONFIRM_BUTTON 좌표 (또는 "확인")를 눌러줘야 합니다[78]. 따라서 발행 후 1초 정도 대기하고, CONFIRM_BUTTON 좌표를 탭하는 것을 조건부로 수행합니다 (만약 좌표가 저장되어 있고 이런 창이 있다고 가정하고 구현).
9단계: 공유 및 링크 복사 – 글이 발행되면 공유 팝업이 뜬다고 가정하고, 저장된 SHARE_BUTTON 좌표를 탭합니다[79]. 이어서 링크 복사 버튼 좌표(COPY_LINK_BUTTON)를 탭하여 블로그 URL을 클립보드에 복사합니다[80]. 그런 다음 ADBController.get_clipboard()를 호출하면 방금 복사한 글 URL을 획득할 수 있습니다[81]. 이 URL을 백엔드 로직에서 받아 DB에 저장하거나 관리자 UI에 표시하면, 어떤 글이 발행되었는지 추적할 수 있게 됩니다. (예: DeviceManager.post_blog(...)의 리턴값으로 URL을 포함시켜 프론트에 전달).
후처리 – 모든 과정이 끝나면, 정상 완료인지 여부에 따라 로그를 남기고 상태를 업데이트합니다. 만약 프로필의 모든 좌표로 포스팅을 한 번 성공했다면 해당 프로필의 calibration_confidence를 좀 더 높게 (예: 0.95->1.0) 설정하거나, last_used_at과 usage_count 등을 업데이트하여 신뢰도 트래킹에 활용합니다[82]. 실패한 단계가 있다면 그 좌표의 fail_count를 증가시켜 향후 개선이 필요함을 표시합니다. 또한 ADB 연결 세션이 혹시 남아있다면 ADBController.disconnect()로 정리합니다[83]. 필요시, stop_app("com.nhn.android.blog")으로 블로그 앱을 종료해 초기 상태로 만들어 줄 수도 있습니다[84][85].
위 단계들은 순차적인 절차형 알고리즘으로 기술했지만, 구현은 가급적 모듈화된 함수들로 분리하는 것을 권장합니다. 예컨데 “텍스트 입력” 부분은 def input_text_field(element_type, text): ... 형태로 ADBController 메서드 호출과 clipboard 처리 등을 캡슐화하면 재사용이 가능해집니다. 또한 “이미지 선택”이나 “발행 후 확인” 같은 부분도 상황에 따라 건너뛸 수 있도록 옵션화하면 유연성이 올라갑니다.
중요: 현재는 UI 상태를 적극적으로 검증하는 AI 통합이 없으므로, 각 단계 사이 충분한 지연과 단순한 검증(예: activity 이름 변화, 특정 UI 요소 존재 여부 확인)만으로 흐름을 제어합니다. 하지만 향후에는 AI Vision API를 활용해 각 단계 실행 후 화면을 분석하고 다음 행동을 결정하는 루프로 고도화할 계획입니다[59][60]. 예컨대, “+ 버튼 눌렀는데 메뉴가 안 열렸다”를 Vision이 감지하면 좌표를 보정하거나 UIAutomator2로 대체 누르는 식입니다. 이러한 스마트 경로조정은 Layer3~4의 영역이지만, Layer1에서도 설계 단계부터 고려하여, 자동화 루틴을 구현할 때 확장 가능한 구조로 만드는 것이 좋습니다. (예: 매 단계 if verify_step_success(): continue else: handle_failure() 형태로 짜두기).
마지막으로, 경로 자동화 구현 시 인적 행동을 모방하는 것이 중요합니다. 따라서 각 터치 사이에 랜덤 딜레이를 주거나, 일부러 화면 스크롤이나 빈 화면 탭을 간간이 섞어 봇 탐지 회피도 고려할 수 있습니다[86][87]. 이러한 세부사항까지 포함하면 Layer1에서 목표한 “사람스러움”을 최대한 달성할 수 있을 것입니다.
6. 클로드코드에게 줄 피드백 초안 📝
⚙️ 향후 개발 및 개선을 위한 지시사항 (Claude 코드에 대한 피드백):
라우팅 버그 수정: Next.js 경로 설정을 실제 의도대로 동작시키기 위해 (admin) 폴더를 제거하거나 rename하세요. 현재 (admin) 폴더로 인해 URL에 admin이 누락되어 404 오류가 발생했으므로[56], 이를 app/admin/ 구조로 바꿔 URL 경로와 UI 링크를 모두 /admin/*로 정리해주세요. 또한 AdminLayout의 내비게이션 링크 href도 같이 조정하고[24], README의 접속 경로 안내 (/admin Dashboard 등)도 업데이트 바랍니다.
UI 자동화 시퀀스 구현: 수집된 좌표를 이용해 블로그 포스팅 전체 과정을 자동화하는 함수를 작성해주세요. 예를 들어 DeviceManager에 def execute_post_sequence(profile_id, post: PostContent)를 만들어, 해당 프로필의 좌표들을 읽어들이고 ADBController를 통해 차례로 플러스 → 블로그쓰기 → 제목 입력 → 본문 입력 → 이미지 첨부 → 글자크기 조정 → 발행 → 확인 → 공유 → 링크복사 액션을 수행하도록 합니다. 각 단계 사이에 time.sleep()으로 자연스러운 지연을 주고, 가능하면 get_current_activity() 등으로 다음 단계 진행 가능 여부를 검증하는 로직을 넣으세요[88]. 예외 발생 시 (예: 좌표 터치에 실패하거나 앱이 예상대로 안 넘어갈 때) 즉시 함수를 빠져나오지 말고, 한 번 더 재시도하거나 실패를 기록한 후 다음 단계로 넘어가도록 내구성 있게 짜주세요. (추가: 나중에 UIAutomator2나 Vision을 통합할 것을 고려해, 이 함수의 구조를 확장 가능하게 설계하면 좋습니다.)
좌표 캘리브레이션 로직 리팩토링: CALIBRATION_STEPS 목록과 _initialize_default_coordinates의 UI 요소 정의 중복을 제거해주세요. 하나의 중앙 테이블/리스트를 참조해서 기본 좌표와 단계 가이드를 모두 생성하도록 구조를 개선합니다. 예를 들어 app/services/calibration_service.py에 UI_ELEMENTS = [...]{ element_type, name, help_text, default_coord_formula } 식의 리스트를 두고, DeviceManager 초기화 시 이를 돌며 CoordinateConfig를 만들도록 하면 일관성이 유지됩니다. 또한 Enum 타입과 리스트 내용의 오타/오용 수정: BOLD_BUTTON을 “가장 작은 글씨”로 쓰는 대신 SMALL_TEXT_OPTION같은 새 타입으로 분리하고, HOME_BUTTON은 WRITE_MENU_BUTTON 등으로 이름을 바꾸는 것을 제안합니다. 이 변경에 따라 프론트엔드 CalibrationWizard에서도 해당 타입값을 같이 업데이트해야 하니 누락 없도록 합니다[19]. (참고: 기본 좌표 목록에도 COPY_LINK_BUTTON 좌표를 추가해 주세요 – 현재 누락됨.)
ADB 제어 개선: ADBController 관련 몇 가지 개선 사항입니다. 1) 안정성: connect() 함수가 실패할 경우를 대비해 재시도 매커니즘을 넣을 수 있을지 검토하세요 (ex: 0.5초 간격으로 3번까지 시도).
7) 클립보드 활용: input_text()로는 한글 입력이 안 되는 문제가 있으니, Post 콘텐츠 입력 시 set_clipboard + paste 조합을 기본 메서드화 (def input_text_smart(text))하여, 내부에서 문자열 종류에 따라 자동 결정하도록 만들면 편리합니다[73][89].
8) 자원해제: 현재 disconnect()는 단순히 _device = None으로만 되어 있는데[90], 필요하면 adb.kill_server() 등을 호출해 세션을 완전히 끊는 것도 고려하세요. 특히 다중 디바이스를 번갈아 제어할 경우 리소스 누수가 없도록 확인 바랍니다.
에러 핸들링 & Fallback 로직 추가: 자동화 순서 실행 중간에 오류 상황별 대응 루틴을 추가하세요. 예를 들어 “+ 버튼”을 눌렀는데 메뉴가 안 열리면 좌표가 틀렸을 가능성 있음 -> 동일 좌표 한 번 더 탭, 그래도 안 되면 오류 로그 기록 후 다음 단계로 건너뛰기. “발행” 후 공유 화면이 안 뜨면 -> 일정 시간 기다린 후 다시 발행 버튼 탭 혹은 프로세스 중단. 이러한 분기 로직을 코드에 명시적으로 넣어둬야, 실제 운영 시 예상치 못한 UI 지연이나 튕김에 대응 가능합니다[59]. 나아가 UIAutomator2를 사용할 수 있게 되면, 좌표 탭 실패 시 UIAutomator2로 해당 요소 Resource-ID를 찾아 눌러보는 이중 시도도 구현할 수 있으니, 현재 구조에 훗날 쉽게 끼워넣을 수 있도록 함수 분리를 잘 해두세요. (예: _tap_with_fallback(x,y, selector=None) 형태로).
화면 스트리밍 성능 개선 준비: 현 WebSocket 스트리밍은 초당 2장 PNG 전송으로 부하가 큰 방식입니다[22]. 당장은 용인하더라도, 향후 scrcpy나 미디어 서버로 전환할 것을念頭에 두고 코드를 작성해주세요. 예를 들어 WebSocket 처리부를 CalibrationStreamer 클래스로 추상화해두면 나중에 내부 구현만 바꾸기 쉽습니다. Phase 2에서 계획된 scrcpy WebSocket 연동[63]이 가능해지면, 현재의 controller.screenshot_base64() 루프를 대체하게 될 것입니다. 또한 프론트엔드에서도 <canvas> 대신 <video> 태그로 쉽게 전환할 수 있게, 스트리밍 방식 변경에 유연하도록 해주세요.
프론트엔드 UX 개선: 관리자 대시보드 사용성을 높이기 위한 몇 가지 피드백입니다.
프로필 연결 후 alert()로 알리는 대신, 토스트 메시지나 상태 표기로 바꾸고 페이지를 전체 리로드하지 말고 상태만 갱신하도록 개선 바랍니다[28]. 예를 들어 profiles 상태 배열을 React state로 관리하면서, connect 성공 시 새 프로필을 해당 배열에 추가하는 식으로 처리하면 사용자 경험이 향상됩니다.
Devices 페이지에 프로필 목록을 표시하여, 이미 등록된 기기들의 calibrated 여부나 메모를 한눈에 보이게 해주세요. 그리고 각 프로필에 “캘리브레이션 시작” 버튼을 제공하면, Calibration 페이지로 이동할 때 URL에 query (?profile=<id>)를 붙여 해당 프로필을 바로 선택할 수 있게 됩니다 (지금도 searchParams.profile로 이를 지원하고 있으니 활용하세요[91][92]).
좌표 캘리브레이션 진행 중, 현재 단계의 UI 요소 이름(예: “발행 버튼”)을 화면 or 버튼에 표시해 주세요. 지금은 지시문 텍스트만 있는데, 사용자가 헷갈릴 수 있으니 “(5/11) 발행 버튼: ... 안내 ...” 식으로 표시하면 좋겠습니다.
마지막으로, Calibration 완료 후 바로 해당 프로필로 자동화 실행을 해볼 수 있는 버튼도 고려해보세요 (예: “✅ 모든 좌표 설정 완료! [테스트 실행]” 버튼). 이를 누르면 앞서 구현한 자동화 루틴을 호출하여 실제로 한 사이클 돌려보고 결과(성공/실패 여부, 복사된 링크 등)를 사용자에게 피드백할 수 있습니다. 이는 곧바로 안 구현하더라도 UX 아이디어로 공유드립니다.
로그 및 모니터링: DebugLogger로 이벤트를 수집하고 있으니, 중요 이벤트에 대한 알림/표시를 개발 단계에서 적극 활용하세요. 예를 들어 자동화 실행 함수 내 각 단계 진입/성공 시 logger.info("Step X succeeded") 등의 로그를 남기고, 실패 시 debug_logger.log_error(...)를 호출하여[93] 세션 로그에 기록을 남깁니다. 추후 100개 계정을 동시에 운영할 때는 이러한 로그들이 문제 원인 파악에 핵심이 될 것이므로, 로그 메시지에 프로필ID, 단계명, 오류내용 등을 구체적으로 기재하도록 신경써 주세요.
以上의 피드백을 참고하여 코드 수정 및 기능 구현을 진행해 주세요. 수정 완료 후에는 유닛테스트 혹은 실제 디바이스로 각 시나리오를 빠짐없이 검증하고, README의 로드맵 체크박스도 업데이트하면 좋겠습니다 (e.g., “Device Manager Service – Done”, “Calibration Service – Done”, “Automation Routine – In Progress” 등[94]). 👍

[1] [2] [94] README.md
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/README.md
[3] [4] [66] devices.py
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/backend/app/api/v1/devices.py
[5] [6] [16] [17] [18] [19] [20] [21] [22] [23] [31] [32] [57] [72] [75] [76] [77] [78] [79] [80] calibration.py
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/backend/app/api/v1/calibration.py
[7] [8] [9] [10] [39] device_manager.py
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/backend/app/services/device_manager.py
[11] [12] [13] [14] [15] [48] [64] [65] [73] [81] [83] [84] [85] [88] [89] [90] adb_controller.py
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/backend/app/services/adb_controller.py
[24] [25] layout.tsx
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/frontend/src/app/(admin)/layout.tsx
[26] [27] [28] [33] [34] device-scanner.tsx
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/frontend/src/components/devices/device-scanner.tsx
[29] [30] [35] [36] [61] [62] [70] [92] calibration-wizard.tsx
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/frontend/src/components/calibration/calibration-wizard.tsx
[37] [38] [43] [44] [47] [49] [74] [82] coordinate.py
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/backend/app/models/coordinate.py
[40] [41] [42] [69] device.py
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/backend/app/models/device.py
[45] [46] [54] [55] [56] [58] [59] [60] [63] [71] [86] [87] 251108-Layer_1(DeviceMandeger)
https://www.notion.so/2a5b8018d36880308e01e810089aa06e
[50] [51] main.py
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/backend/main.py
[52] [53] [93] debug_logger.py
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/backend/app/services/debug_logger.py
[67] README.md
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/frontend/README.md
[68] api-client.ts
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/frontend/src/lib/api-client.ts
[91] page.tsx
https://github.com/shinjadong/careon-blog-ai/blob/18fef2368bc6a5dc33157dd0c15a1a7ab4541f0a/frontend/src/app/(admin)/calibration/page.tsx
